
     //*** Lab4 ***
/***********************************************************************************************
    File Name:  ELNC6007SKLab4.c
    Author:     KSangeetha
    Date:       27/03/2020
    Modified:   None
     Fanshawe College, 2016

    Description: Fermentation system
    
***********************************************************************************************/

// Preprocessor ===================================================================
#include <stdlib.h>
#include <stdio.h>
#include "mbed.h"

// Constants ======================================================================

#define TRUE 1
#define FALSE 0

#define LED_ON 1                // Simple way to handle the LED operation,
#define LED_OFF 0           

#define HIGH 1
#define LOW 0
                    
#define TMR0FLAG INTCONbits.TMR0IF
#define GO ADCON0bits.GO
#define MAXSAMP 30

#define TEMP 0X01
#define PRES 0X05
#define CO2 0x09

#define SENSNUM 3
#define MTR 2
#define SIZE 4

#define TCOEFF 0.0285
#define TOFFSET 1.4285
#define PCOEFF 0.02
#define CCOEFF 0.00278
#define CCOFFSET -0.556

#define PBMASK 0XFF
#define CHANSELECT 2

#define T 0
#define P 1
#define C 2

#define TEMPHIGH 65
#define TEMPLOW 12
#define PRESHIGH 103
#define PRESLOW 17
#define CHIGH 1200
#define CLOW 350

#define PATTERN4 0X08
#define PATTERN3 0X04
#define PATTERN2 0X02
#define PATTERN1 0X01

#define COUNT 4
#define ONESEC 4

#define BUFSIZE 30
#define CONTROLLER 1
#define ADDRESS 888


// Global Variables ===============================================================
Serial pc(USBTX,USBRX);
DigitalIn pb1(p5);
DigitalIn pb2(p6);
DigitalIn pb3(p7);
DigitalIn pb4(p8);
DigitalOut myled(LED1);                                       

char buf[BUFSIZE]={0}; //Creating an array of buffer size 30
char flag=FALSE;
int count=0;             

typedef struct sensorCh    //creating data structure for sensor channels
{
    int currentSample;  
    int sample[MAXSAMP];
    int avgSample;
    int insertAt;
    int highLimit;
    int lowLimit;
    int state;
    char avgRdy;
}sensorCh_t;

typedef struct motor  //Data structure for motor and dampener
{
    int position;
    int currentPosition;
    int pattern;
    int patternCounter;
    int data;
    int control;
}motor_t;


typedef struct fvs    // creating data structure for fvs
{
    char address[SIZE];
    sensorCh_t sensors[SENSNUM];
    motor_t motor[MTR];
    char mode;
    char chanSel;
    int indicator;
    int heater;
}fvs_t;
fvs_t fvs888;


// Functions ======================================================================

/*** initialiseFvs: **************************************************************
Author:     KSangeetha
Date:       27 Jan,2020
Modified:   None
Desc:       Initialising of FVS
Input:      None
Returns:    None
**********************************************************************************/
void initialiseFvs(void)  
{
    int i=0;
    for(i=0;i<MAXSAMP;i++)
    {   
        fvs888.sensors[T].sample[i]=0;
    }
    fvs888.sensors[T].currentSample=FALSE;
    fvs888.sensors[T].avgSample=FALSE;
    fvs888.sensors[T].highLimit=TEMPHIGH;
    fvs888.sensors[T].lowLimit=TEMPLOW;
    fvs888.sensors[T].state=FALSE;
    fvs888.sensors[T].insertAt=0;
    fvs888.sensors[T].avgRdy = FALSE;   //initially average ready is zero

    for(i=0;i<MAXSAMP;i++)
    {   
        fvs888.sensors[P].sample[i]=0;
    }
    fvs888.sensors[P].currentSample=FALSE;
    fvs888.sensors[P].avgSample=FALSE;
    fvs888.sensors[P].highLimit=PRESHIGH;
    fvs888.sensors[P].lowLimit=PRESLOW;
    fvs888.sensors[P].state=FALSE;
    fvs888.sensors[P].insertAt=0;
    fvs888.sensors[P].avgRdy = FALSE;

    for(i=0;i<MAXSAMP;i++)
    {   
        fvs888.sensors[C].sample[i]=0;
    }
    fvs888.sensors[C].currentSample=FALSE;
    fvs888.sensors[C].avgSample=FALSE;
    fvs888.sensors[C].highLimit=CHIGH;
    fvs888.sensors[C].lowLimit=CLOW;
    fvs888.sensors[C].state=FALSE;
    fvs888.sensors[C].insertAt=0;
    fvs888.sensors[C].avgRdy = FALSE;

    fvs888.motor[0].position=357; //motor position is 357
    fvs888.motor[0].currentPosition=0;
    fvs888.motor[0].pattern=0;
    fvs888.motor[0].patternCounter=0;
    fvs888.motor[0].data=0;
    fvs888.motor[0].control=0;
    
    fvs888.motor[1].position=30; //dampener position is 30
    fvs888.motor[1].currentPosition=0;
    fvs888.motor[1].pattern=0;
    fvs888.motor[1].patternCounter=0;
    fvs888.motor[1].data=0;
    fvs888.motor[1].control=0;
}
//eo initialiseFvs function::


/********mode**********************************
Author:     KSangeetha
Date:       14 Feb,2020     
Modified:   None
Desc:       Checks if the mode is high or low limit
Input:      None
Returns:    None
**********************************************************************************/

void mode(void)
{
    fvs888.mode=!fvs888.mode;    // points to low or high limit
}
//eo mode function::

/***ChanSel******************************************************
Author:     KSangeetha
Date:       14 Feb,2020     
Modified:   None
Desc:       Checks if the channel is temperature or pressure
Input:      None
Returns:    None
**********************************************************************************/
void chanSel(void)
{
    fvs888.chanSel++;
    if(fvs888.chanSel>=3) //assigning values to each channel
    {
        fvs888.chanSel=0;       
    }
}
//eo channel select function::


/***increment******************************************************
Author:     KSangeetha
Date:       14 Feb,2020     
Modified:   None
Desc:       Increment operation
Input:      None
Returns:    None
**********************************************************************************/
void increment(void)
{
    flag=TRUE;  //declaring flag to true so that when flag is caleed, it can be used to print CONLIM statement when increment button is pressed
    if(fvs888.mode==HIGH)
    {
        if(fvs888.chanSel==T)
        {
            fvs888.sensors[T].highLimit++;
        }
        else if(fvs888.chanSel==P)
        {
            fvs888.sensors[P].highLimit++;
        }
        else if(fvs888.chanSel==C)
        {
            fvs888.sensors[C].highLimit++;
        }
    }

    else if(fvs888.mode==LOW)
    {
        if(fvs888.chanSel==T)
        {
            fvs888.sensors[T].lowLimit++;
        }
        else if(fvs888.chanSel==P)
        {
            fvs888.sensors[P].lowLimit++;
        }   
        else if(fvs888.chanSel==C)
        {
            fvs888.sensors[C].lowLimit++;
        }                   
    }
}
//eo increment function::

/***decrement******************************************************
Author:     KSangeetha
Date:       14 Feb,2020     
Modified:   None
Desc:       Decrement operation
Input:      None
Returns:    None
**********************************************************************************/
void decrement(void)
{
    flag=TRUE;
    if(fvs888.mode==HIGH)
    {
        if(fvs888.chanSel==T)
        {
            fvs888.sensors[T].highLimit--;
        }
        else if(fvs888.chanSel==P)
        {
            fvs888.sensors[P].highLimit--;
        }
        else if(fvs888.chanSel==C)
        {
            fvs888.sensors[C].highLimit--;
        }
    }//eo if statement::

    else if(fvs888.mode==LOW)
    {
        if(fvs888.chanSel==T)
        {
            fvs888.sensors[T].lowLimit--;
        }
        else if(fvs888.chanSel==P)
        {
            fvs888.sensors[P].lowLimit--;
        }
        else if(fvs888.chanSel==C)
        {
            fvs888.sensors[C].lowLimit--;
        }
    }
}
//eo decrement function::


/***pbState******************************************************
Author:     KSangeetha
Date:       14 Feb,2020     
Modified:   None
Desc:       Pushbutton operation 
Input:      None
Returns:    None
**********************************************************************************/
void pbState(void)
{
    if(pb1==FALSE)
    {
        mode(); //calling of mode when mode is low
    }
    else if(pb2==FALSE)
    {
        chanSel(); //calling of channel select if channel is false
    }
    else if(pb3==FALSE)
    {
        increment();
    }
    else if(pb4==FALSE)
    {
        decrement();
    }
}
//eo pbstate::



/*** initializeSystem: ***********************************************************
Author:     CTalbot
Date:       14 Sept, 2016
Modified:   KSangeetha 
Desc:       Initalizing all the functions
Input:      None
Returns:    None
**********************************************************************************/
void initializeSystem(void)
{
    initialiseFvs();    
}   
// eo initializeSystem::**********************************************************


/***calcChecksum******************************************************
Author:     KSangeetha
Date:       26 March,2020       
Modified:   None
Desc:       checksum calculation using pointers 
Input:      None
Returns:    None
**********************************************************************************/
char calcChecksum(char*ptr)
{
    char cs=0;
    while(*ptr)
    {
        cs^=*ptr;
        ptr++;
    }
    return cs;
}//eo calcChecksum::

/***printSentence: **************************************************************
Author:     KSangeetha
Date:       26 March,2020
Modified:   None
Desc:       The CONLIM sentence is printed in this function
Input:      None
Returns:    None
**********************************************************************************/
void printSentence(void)
{
    int output=0;
    if(fvs888.mode==LOW)
    {
        fvs888.mode=0;
    }
    else
    {
        fvs888.mode=1;
    }
    if(fvs888.mode==HIGH&&fvs888.chanSel==T)
    {
        output=fvs888.sensors[T].highLimit;
    }
    else if(fvs888.mode==LOW&&fvs888.chanSel==T)
    {
        output=fvs888.sensors[T].lowLimit;
    }
    else if(fvs888.mode==HIGH&&fvs888.chanSel==P)
    {
        output=fvs888.sensors[P].highLimit;
    }
    else if(fvs888.mode==LOW&&fvs888.chanSel==P)
    {
        output=fvs888.sensors[P].lowLimit;
    }
    else if(fvs888.mode==HIGH&&fvs888.chanSel==C)
    {
        output=fvs888.sensors[C].highLimit;
    }
    else if(fvs888.mode==LOW&&fvs888.chanSel==C)
    {
        output=fvs888.sensors[C].lowLimit;
    }
    sprintf(buf,"$CONLIM,%i,%i,%i,%i,%i\0",CONTROLLER,ADDRESS,fvs888.chanSel,fvs888.mode,output);
    sprintf(buf,"%s,%i#\0",buf,calcChecksum(buf));

}//eo printSentence::
    
/***displayFunc : **************************************************************
Author:     KSangeetha
Date:       26 March,2020
Modified:   None
Desc:       Displaying of the functions on the output screen.
Input:      None
Returns:    None
**********************************************************************************/

void displayFunc(void)
{ 
        pc.printf("\033[2J\033[0;0HFVS888 SYSTEM888 PROPERTIES\r\n");
        if(fvs888.chanSel==T)
        {
            pc.printf("\033[2;0HChannel Selected:Temperature\t\r\n");
        }
        else if(fvs888.chanSel==P)
        {
            pc.printf("\033[2;0HChannel Selected:Pressure\t\r\n");
        }
        else 
        {
            pc.printf("\033[2;0HChannel Selected:Carbondioxide\t\r\n");
        }
        if(fvs888.mode==0)
        {
            pc.printf("\033[2;50HMode:Low\r\n");
        }
        else
        {
            pc.printf("\033[2;50HMode:High\r\n");
        }
        pc.printf("\033[3;0HTEMPERATURE\033[3;25HPRESSURE\033[3;50HCO2\033[9;0HMotor1:Discharge\033[9;25HMotor2:Dampener\t\t\r\n");
        pc.printf("\033[4;0HCurrent:\t%i%cC\033[4;25HCurrent:\t%ikPa\033[4;50HCurrent:\t%ippm\033[10;0HPosition:\t%d%c\033[10;25HPosition:\t%d%c\r\n",fvs888.sensors[T].avgSample,248,fvs888.sensors[P].avgSample,fvs888.sensors[C].avgSample,fvs888.motor[0].currentPosition,248,fvs888.motor[1].currentPosition,248);
        pc.printf("\033[5;0HHighLimit:\t%i%cC\033[5;25HHighLimit:\t%ikPa\033[5;50HHighLimit:\t%ippm\r\n",fvs888.sensors[T].highLimit,248,fvs888.sensors[P].highLimit,fvs888.sensors[C].highLimit);
        pc.printf("\033[6;0HLowLimit:\t%i%cC\033[6;25HLowLimit:\t%ikPa\033[6;50HLowLimit:\t%ippm\033[12;0HData:\t0X%02X\r\n\033[12;25HData:\t0X%02X\r\n",fvs888.sensors[T].lowLimit,248,fvs888.sensors[P].lowLimit,fvs888.sensors[C].lowLimit,fvs888.motor[0].pattern,fvs888.motor[1].pattern);

        if(fvs888.sensors[T].avgSample>fvs888.sensors[T].lowLimit&&fvs888.sensors[T].avgSample<fvs888.sensors[T].highLimit)   // when current temperature is between the limits of 12 and 65 degrees)   
        {
            pc.printf("\033[7;0HStatus:\t\033[0;32mSafe\033[0m\r\n");
        }
        else if(fvs888.sensors[T].avgSample<fvs888.sensors[T].lowLimit)   // when current temperature is below low limit (12)
        {
            pc.printf("\033[7;0HStatus:\t\033[0;31mAlarm\033[0m\r\n"); 
        }
        else if(fvs888.sensors[T].avgSample>fvs888.sensors[T].highLimit)   // when current temperature is above the high limit (65)
        {
            pc.printf("\033[7;0HStatus:\t\033[0;31mAlarm\033[0m\r\n"); 
        }
        if(fvs888.sensors[P].avgSample>fvs888.sensors[P].lowLimit&&fvs888.sensors[P].avgSample<fvs888.sensors[P].highLimit)   // when current pressure is between the limits (17 and 103kPa)
        {
            pc.printf("\033[7;25HStatus:\t\033[0;32mSAFE\033[0m\r\n");
        }
        else if(fvs888.sensors[P].avgSample<fvs888.sensors[P].lowLimit)     // when current pressure is below low limit (17)
        {
            pc.printf("\033[7;25HStatus:\t\033[0;31mAlarm\033[0m\r\n");
        }
        else if(fvs888.sensors[P].avgSample>fvs888.sensors[P].highLimit)   // when current pressure is above high limit (103)
        {   
            pc.printf("\033[7;25HStatus:\t\033[0;31mAlarm\033[0m\r\n");
        }

        if(fvs888.sensors[C].avgSample>fvs888.sensors[C].lowLimit||fvs888.sensors[C].avgSample<fvs888.sensors[C].highLimit) //when current CO2 is between the limits 350 and 1200ppm
        {
            pc.printf("\033[7;50HStatus:\t\033[0;32mSAFE\033[0m\r\n");
        }
        if(fvs888.sensors[C].avgSample>fvs888.sensors[C].highLimit) //when current CO2 is above high limit 1200pm
        {
            pc.printf("\033[7;50HStatus:\t\033[0;31mAlarm\033[0m\r\n");
        }
        if(fvs888.sensors[C].avgSample<fvs888.sensors[C].lowLimit)//when current CO2 is less than low limit
        {
            pc.printf("\033[7;50HStatus:\t\033[0;31mAlarm\033[0m\r\n");
        }



        if(fvs888.sensors[T].avgSample<fvs888.sensors[T].lowLimit&&fvs888.sensors[P].avgSample<fvs888.sensors[P].lowLimit)
        {
            pc.printf("\033[11;0HControl:STOP\r\n");
        }   
        if(fvs888.sensors[T].avgSample<fvs888.sensors[T].lowLimit&&fvs888.sensors[P].avgSample>fvs888.sensors[T].highLimit)
        {
            pc.printf("\033[11;0HControl:RUN\r\n");
        }   
        if(fvs888.sensors[T].avgSample>fvs888.sensors[T].highLimit&&fvs888.sensors[P].avgSample<fvs888.sensors[P].lowLimit)
        {
            pc.printf("\033[11;0HControl:RUN\r\n");
        }
        if(fvs888.sensors[T].avgSample>fvs888.sensors[P].highLimit&&fvs888.sensors[P].avgSample>fvs888.sensors[P].highLimit)   
        {
            pc.printf("\033[11;0HControl:RUN\r\n");
        }   
        if(fvs888.sensors[T].avgSample>fvs888.sensors[T].lowLimit&&fvs888.sensors[T].avgSample<fvs888.sensors[T].highLimit)
        {
            pc.printf("\033[11;0HControl:STOP\r\n");
        }
        if(fvs888.sensors[P].avgSample>fvs888.sensors[P].lowLimit&&fvs888.sensors[P].avgSample<fvs888.sensors[P].highLimit)
        {
            pc.printf("\033[11;0HControl:STOP\r\n");
        }
        if(fvs888.sensors[T].avgSample>fvs888.sensors[T].highLimit&&fvs888.sensors[P].avgSample>fvs888.sensors[P].highLimit)
        {
            pc.printf("\033[11;0HControl:RUN\r\n");
        }
        if(fvs888.sensors[T].avgSample>fvs888.sensors[T].lowLimit&&fvs888.sensors[T].avgSample<fvs888.sensors[T].highLimit&&fvs888.sensors[P].avgSample>fvs888.sensors[P].highLimit)
        {
            pc.printf("\033[11;0HControl:RUN\r\n");
        }   
        if(fvs888.sensors[P].avgSample>fvs888.sensors[P].lowLimit&&fvs888.sensors[P].avgSample<fvs888.sensors[P].highLimit&&fvs888.sensors[T].avgSample>fvs888.sensors[T].highLimit) 
        {
            pc.printf("\033[11;0HControl:RUN\r\n");
        }
        if(fvs888.sensors[C].avgSample>fvs888.sensors[C].lowLimit&&fvs888.sensors[C].avgSample<fvs888.sensors[C].highLimit)
        {
            pc.printf("\033[11;25HControl:STOP\r\n");
        }
        if(fvs888.sensors[C].avgSample<fvs888.sensors[C].lowLimit)  
        {
            pc.printf("\033[11;25HControl:STOP\r\n");
        }
        if(fvs888.sensors[P].avgSample>fvs888.sensors[P].highLimit) 
        {
            pc.printf("\033[11;25HControl:RUN\r\n");
        }   
}
//eo displayFunc::



/*********************************************************************************
***** MAIN FUNCTION **************************************************************
**********************************************************************************/

int main()
 {
    int count=0;
    pc.baud(9600);
    initializeSystem(); // Function call for setting the system I/Os and enabling the ADC module
    while(1)    // Begin indefinite loop for program
    {
        pbState();// pushbutton function call
        displayFunc();//calling display function
        if(flag==1&&count<=5)
        {
            count++;
            printSentence();//calling print sentence function 
            pc.printf("\e[K\e[16:0H%s\r",buf); //if count is less than or equal to 5 seconds, then CONLIM statement is printed
        }
        if(count>5) //if count exceeds 5 seconds, then nothing will be displayed in CONLIM
        {
            flag=FALSE;
            count=0;
            pc.printf("\e[K\e[16:0H");
        }       
    }
}//eo main::
      